{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#spatial-k","title":"Spatial K","text":"<p>Spatial K is a set of libraries for working with geospatial data in Kotlin including an implementation of GeoJson and  a port of Turfjs written in pure Kotlin. It supports Kotlin Multiplatform projects and also features a  Kotlin DSL for building GeoJson objects.</p>"},{"location":"#installation","title":"Installation","text":""},{"location":"#java-and-kotlinjvm","title":"Java and Kotlin/JVM","text":"<pre><code>dependencies {\n    implementation \"io.github.dellisd.spatialk:geojson:&lt;version&gt;\"\n    implementation \"io.github.dellisd.spatialk:turf:&lt;version&gt;\"\n}\n</code></pre>"},{"location":"#kotlin-multiplatform","title":"Kotlin Multiplatform","text":"<pre><code>commonMain {\n    dependencies {\n        implementation \"io.github.dellisd.spatialk:geojson:&lt;version&gt;\"\n        implementation \"io.github.dellisd.spatialk:turf:&lt;version&gt;\"\n    }\n}\n</code></pre>"},{"location":"#snapshots","title":"Snapshots","text":"<p>Snapshot builds are available on Sonatype.</p> <pre><code>repositories {\n    maven { url \"https://oss.sonatype.org/content/repositories/snapshots/\" }\n}\n</code></pre>"},{"location":"#supported-targets","title":"Supported targets","text":"<p>Spatial K currently supports the following platform targets: <code>jvm</code>, <code>js</code>, <code>mingwX64</code>, <code>linuxX64</code>, <code>macosX64</code>, <code>iosX64</code>, <code>iosArm64</code>, and <code>iosArm32</code>.</p>"},{"location":"geojson/","title":"GeoJson","text":"<p>The <code>geojson</code> module contains an implementation of the GeoJson standard.</p> <p>See below for constructing GeoJson objects using the DSL.</p>"},{"location":"geojson/#installation","title":"Installation","text":"KotlinGroovy <pre><code>dependencies {\n    implementation(\"io.github.dellisd.spatialk:geojson:&lt;version&gt;\")\n}\n</code></pre> <pre><code>dependencies {\n    implementation \"io.github.dellisd.spatialk:geojson:&lt;version&gt;\"\n}\n</code></pre>"},{"location":"geojson/#geojson-objects","title":"GeoJson Objects","text":"<p>The <code>GeoJson</code> interface represents all GeoJson objects. All GeoJson objects can have a <code>bbox</code> property specified on them which is a <code>BoundingBox</code> that represents the bounds of that object's geometry.</p>"},{"location":"geojson/#geometry","title":"Geometry","text":"<p>Geometry objects are a sealed hierarchy of classes that inherit from the <code>Geometry</code> class. This allows for exhaustive  type checks in Kotlin using a <code>when</code> block.</p> Kotlin <pre><code>val geometry: Geometry = getSomeGeometry()\n\nval type = when (geometry) {\n    is Point -&gt; \"Point\"\n    is MultiPoint -&gt; \"MultiPoint\"\n    is LineString -&gt; \"LineString\"\n    is MultiLineString -&gt; \"MultiLineString\"\n    is Polygon -&gt; \"Polygon\"\n    is MultiPolygon -&gt; \"MultiPolygon\"\n    is GeometryCollection -&gt; \"GeometryCollection\"\n}\n</code></pre> <p>All seven types of GeoJSON geometries are implemented and summarized below. Full documentation can be found in the API pages.</p>"},{"location":"geojson/#position","title":"Position","text":"<p>Positions are implemented as a <code>DoubleArray</code>-backed class. Each component (<code>longitude</code>, <code>latitude</code>, <code>altitude</code>) can be accessed by its propery. The class also supports destructuring.</p> <p>Positions are implemented as an interface where the longitude, latitude, and optionally an altitude are accessible as  properties. The basic implementation of the <code>Position</code> interface is the <code>LngLat</code> class.</p> KotlinJSON <pre><code>val position: Position = Position(-75.0, 45.0)\nval (longitude, latitude, altitude) = position\n\n// Access values\nposition.longitude\nposition.latitude\nposition.altitude // null if unspecified\n</code></pre> <pre><code>[-75, 45]\n</code></pre>"},{"location":"geojson/#point","title":"Point","text":"<p>A Point is a single Position.</p> KotlinJSON <pre><code>val point = Point(Position(-75.0, 45.0))\n\nprintln(point.longitude) \n// Prints: -75.0\n</code></pre> <pre><code>{\n    \"type\": \"Point\",\n    \"coordinates\": [-75, 45]\n}\n</code></pre>"},{"location":"geojson/#multipoint","title":"MultiPoint","text":"<p>A <code>MultiPoint</code> is an array of Positions.</p> KotlinJSON <pre><code>val multiPoint = MultiPoint(Position(-75.0, 45.0), Position(-79.0, 44.0))\n</code></pre> <pre><code>{\n    \"type\": \"MultiPoint\",\n    \"coordinates\": [[-75, 45], [-79, 44]]\n}\n</code></pre>"},{"location":"geojson/#linestring","title":"LineString","text":"<p>A <code>LineString</code> is a sequence of two or more Positions.</p> KotlinJSON <pre><code>val lineString = LineString(Position(-75.0, 45.0), Position(-79.0, 44.0))\n</code></pre> <pre><code>{\n    \"type\": \"LineString\",\n    \"coordinates\": [[-75, 45], [-79, 44]]\n}\n</code></pre>"},{"location":"geojson/#multilinestring","title":"MultiLineString","text":"<p>A <code>MultiLineString</code> is an array of LineStrings.</p> KotlinJSON <pre><code>val multiLineString = MultiLineString(\n    listOf(Position(12.3, 45.6), Position(78.9, 12.3)),\n    listOf(Position(87.6, 54.3), Position(21.9, 56.4))\n)\n</code></pre> <pre><code>{\n    \"type\": \"MultiLineString\",\n    \"coordinates\": [\n        [[12.3, 45.6], [78.9, 12.3]],\n        [[87.6, 54.3], [21.9, 56.4]]\n    ]\n}\n</code></pre>"},{"location":"geojson/#polygon","title":"Polygon","text":"<p>A <code>Polygon</code> is an array of rings. Each ring is a sequence of points with the last point matching the first point to indicate a closed area. The first ring defines the outer shape of the polygon, while all the following rings define \"holes\" inside the polygon.</p> KotlinJSON <pre><code>val polygon = Polygon(\n    listOf(\n        Position(-79.87, 43.42),\n        Position(-78.89, 43.49),\n        Position(-79.07, 44.02),\n        Position(-79.95, 43.87),\n        Position(-79.87, 43.42)\n    ),\n    listOf(\n        Position(-79.75, 43.81),\n        Position(-79.56, 43.85),\n        Position(-79.7, 43.88),\n        Position(-79.75, 43.81)\n    )\n)\n</code></pre> <pre><code>{\n    \"type\": \"Polygon\",\n    \"coordinates\": [\n        [[-79.87, 43.42], [-78.89, 43.49], [-79.07, 44.02], [-79.95, 43.87], [-79.87, 43.42]],\n        [[-79.75, 43.81], [-79.56, 43.85], [-79.7, 43.88], [-79.75, 43.81]]\n    ]\n}\n</code></pre>"},{"location":"geojson/#multipolygon","title":"MultiPolygon","text":"<p>A <code>MultiPolygon</code> is an array of Polygons.</p> KotlinJSON <pre><code>val polygon = listOf(\n    Position(-79.87, 43.42),\n    Position(-78.89, 43.49),\n    Position(-79.07, 44.02),\n    Position(-79.95, 43.87),\n    Position(-79.87, 43.42)\n),\nlistOf(\n    Position(-79.75, 43.81),\n    Position(-79.56, 43.85),\n    Position(-79.7, 43.88),\n    Position(-79.75, 43.81)\n)\nval multiPolygon = MultiPolygon(polygon, polygon)\n</code></pre> <pre><code>{\n    \"type\": \"MultiPolygon\",\n    \"coordinates\": [\n        [\n            [[-79.87, 43.42], [-78.89, 43.49], [-79.07, 44.02], [-79.95, 43.87], [-79.87, 43.42]],\n            [[-79.75, 43.81], [-79.56, 43.85], [-79.7, 43.88], [-79.75, 43.81]]\n        ],\n        [\n            [[-79.87, 43.42], [-78.89, 43.49], [-79.07, 44.02], [-79.95, 43.87], [-79.87, 43.42]],\n            [[-79.75, 43.81], [-79.56, 43.85], [-79.7, 43.88], [-79.75, 43.81]]\n        ]\n    ]\n}\n</code></pre>"},{"location":"geojson/#geometrycollection","title":"GeometryCollection","text":"<p>A <code>GeometryCollection</code> is a collection of different types of Geometry. It implements the <code>Collection</code> interface and can be used in any place that a collection can be used.</p> KotlinJSON <pre><code>val geometryCollection = GeometryCollection(point, lineString)\n\n// Can be iterated over, and used in any way a Collection&lt;T&gt; can be\ngeometryCollection.forEach { geometry -&gt;\n    // ...\n}\n</code></pre> <pre><code>{\n    \"type\": \"GeometryCollection\",\n    \"coordinates\": [\n        {\n            \"type\": \"Point\",\n            \"coordinates\": [-75, 45]\n        },\n        {\n            \"type\": \"LineString\",\n            \"coordinates\": [[-75, 45], [-79, 44]]\n        }\n    ]\n}\n</code></pre>"},{"location":"geojson/#feature","title":"Feature","text":"<p>A <code>Feature</code> can contain a <code>Geometry</code> object, as well as a set of data properties, and optionally a commonly used identifier (<code>id</code>).</p> <p>A feature's properties are stored as a map of <code>JsonElement</code> objects from <code>kotlinx.serialization</code>.  A set of helper methods to get and set properties with the appropriate types directly.</p> KotlinJSON <pre><code>val feature = Feature(point)\nfeature.setNumberProperty(\"size\", 9999)\n\nval size: Number? = feature.getNumberProperty(\"size\") // 9999\nval geometry: Geometry? = feature.geometry // point\n</code></pre> <pre><code>{\n    \"type\": \"Feature\",\n    \"geometry\": \n    {\n        \"type\": \"Point\",\n        \"coordinates\": [-75, 45]\n    },\n    \"properties\": \n    {\n        \"size\": 9999\n    }\n}\n</code></pre>"},{"location":"geojson/#featurecollection","title":"FeatureCollection","text":"<p>A <code>FeatureCollection</code> is a collection of multiple features. <code>FeatureCollection</code> implements the <code>Collection</code> interface and can be used in any place that a collection can be used.  </p> KotlinJSON <pre><code>val featureCollection = FeatureCollection(pointFeature)\n\nfeatureCollection.forEach { feature -&gt;\n    // ...\n}\n</code></pre> <pre><code>{\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        {\n            \"type\": \"Feature\",\n            \"geometry\": \n            {\n                \"type\": \"Point\",\n                \"coordinates\": [-75, 45]\n            },\n            \"properties\": \n            {\n                \"size\": 9999\n            }\n        }\n    ]\n}\n</code></pre>"},{"location":"geojson/#boundingbox","title":"BoundingBox","text":"<p>The <code>BoundingBox</code> class is used to represent the bounding boxes that can be set for any <code>GeoJson</code> object. Like the <code>Position</code> class, bounding boxes are backed by a <code>DoubleArray</code> with each component accessible by its propery (<code>southwest</code> and <code>northeast</code>). Bounding boxes also support destructuring.</p> KotlinJSON <pre><code>val bbox = BoundingBox(west = 11.6, south = 45.1, east = 12.7, north = 45.7)\nval (southwest, northeast) = bbox // Two Positions\n</code></pre> <pre><code>[11.6, 45.1, 12.7, 45.7]\n</code></pre>"},{"location":"geojson/#serialization","title":"Serialization","text":""},{"location":"geojson/#to-json","title":"To Json","text":"<p>Any <code>GeoJson</code> object can be serialized to a JSON string using the <code>json()</code> function. This function converts the object to JSON using string concatenation and is therefore very fast. </p> Kotlin <pre><code>val featureCollection: FeatureCollection = getFeatureCollection()\n\nval json = featureCollection.json()\nprintln(json)\n</code></pre> <p>Spatial-K is also fully compatible with <code>kotlinx.serialization</code> to allow for integration into more complex models, however this is much slower. For encoding directly to JSON strings, prefer to use the <code>json()</code> function.</p>"},{"location":"geojson/#from-json","title":"From Json","text":"<p>The <code>fromJson</code> and <code>fromJsonOrNull</code> companion (or static) functions are available on each <code>GeoJson</code> class to decode each  type of object from a JSON string.</p> KotlinJava <pre><code>// Throws exception if the JSON cannot be deserialized to a Point\nval myPoint = Point.fromJson(\"{...geojson...}\")\n\n// Returns null if an error occurs\nval nullable = Point.fromJsonOrNull(\"{...not a point...}\")\n</code></pre> <pre><code>// Throws exception if the JSON cannot be deserialized to a Point\nvar myPoint = Point.fromJson(\"{...geojson...}\")\n\n// Returns null if an error occurs\nvar nullable = Point.fromJsonOrNull(\"{...not a point...}\")\n</code></pre> <p>Like with encoding, Spatial-K objects can also be decoded using <code>kotlinx.serialization</code>. </p> Kotlin <pre><code>val feature: Feature = Json.decodeFromString(Feature.serializer(), \"{...feature...}\")\n</code></pre>"},{"location":"geojson/#geojson-dsl","title":"GeoJson DSL","text":"<p>It's recommended to construct GeoJson objects in-code using the GeoJson DSL.</p>"},{"location":"geojson/#positions","title":"Positions","text":"<p>Convenience functions to construct latitude/longitude Position instances is included. These functions will check for valid latitude and longitude values and will throw an <code>IllegalArgumentException</code> otherwise.</p> KotlinJSON <pre><code>lngLat(longitude = -75.0, latitude = 45.0)\n\n// Throws exception!!\nlngLat(longitude = -565.0, latitude = 45.0)\n</code></pre> <pre><code>[-75.0, 45.0]\n</code></pre>"},{"location":"geojson/#geometry_1","title":"Geometry","text":"<p>Each geometry type has a corresponding DSL.</p> <p>A GeoJson object's <code>bbox</code> value can be assigned in any of the DSLs.</p>"},{"location":"geojson/#point_1","title":"Point","text":"KotlinJSON <pre><code>point(longitude = -75.0, latitude = 45.0, altitude = 100.0)\n\n// Or...\n\npoint(Position(12.5, 35.9))\n</code></pre> <pre><code>{\n  \"type\": \"Point\",\n  \"coordinates\": [-75.0, 45.0, 100.0]\n}\n</code></pre>"},{"location":"geojson/#multipoint_1","title":"MultiPoint","text":"<p>The <code>MultiPoint</code> DSL creates a <code>MultiPoint</code> from many <code>Point</code>s, or by using the unary plus operator to add <code>Position</code> instances as positions in the geometry. <code>Point</code> geometries can also be added to the multi point using the unary plus operator.</p> KotlinJSON <pre><code>val myPoint = Point(88.0, 34.0)\nmultiPoint {\n    point(-75.0, 45.0)\n\n    +lngLat(-78.0, 44.0)\n    +myPoint\n}\n</code></pre> <pre><code>{\n  \"type\": \"MultiPoint\",\n  \"coordinates\": [\n    [-75.0, 45.0],\n    [-78.0, 44.0],\n    [88.0, 34.0]\n  ]\n}\n</code></pre>"},{"location":"geojson/#linestring_1","title":"LineString","text":"<p>A <code>LineString</code> contains main points. Like with <code>MultiPoint</code>, a <code>LineString</code> can also be built using the unary plus operator to add positions as part of the line. The order in which positions are added to the <code>LineString</code> is the order that the <code>LineString</code> will follow.</p> KotlinJSON <pre><code>lineString {\n    point(45.0, 45.0)\n    point(0.0, 0.0)\n}\n</code></pre> <pre><code>{\n  \"type\": \"LineString\",\n  \"coordinates\": [[45.0, 45.0], [0.0, 0.0]]\n}\n</code></pre>"},{"location":"geojson/#multilinestring_1","title":"MultiLineString","text":"<p>The <code>MultiLineString</code> DSL uses the unary plus operator to add multiple line strings. The <code>LineString</code> DSL can be used to create <code>LineString</code> objects to add.</p> KotlinJSON <pre><code>val simpleLine = lineString {\n    point(45.0, 45.0)\n    point(0.0, 0.0)\n}\n\nmultiLineString {\n    +simpleLine\n\n    // Inline LineString creation\n    lineString {\n        point(44.4, 55.5)\n        point(55.5, 66.6)\n    }\n}\n</code></pre> <pre><code>{\n  \"type\": \"MultiLineString\",\n  \"coordinates\": [\n    [[45.0, 45.0], [0.0, 0.0]],\n    [[44.4, 55.5], [55.5, 66.6]]\n  ]\n}\n</code></pre>"},{"location":"geojson/#polygon_1","title":"Polygon","text":"<p>The <code>Polygon</code> DSL is used by specifying linear rings that make up the polygon's shape and holes. The first <code>ring</code> is the exterior ring with four or more positions. The last position must be the same as the first position. All <code>ring</code>s that follow will represent interior rings (i.e. holes) in the polygon.</p> <p>For convenience, the <code>complete()</code> function can be used to \"complete\" a ring. It adds the last position in the ring by copying the first position that was added.</p> KotlinJSON <pre><code>val simpleLine = lineString {\n    point(45.0, 45.0)\n    point(0.0, 0.0)\n}\n\npolygon {\n     ring {\n         // LineStrings can be used as part of a ring\n         +simpleLine\n         point(12.0, 12.0)\n         complete()\n     }\n     ring {\n         point(4.0, 4.0)\n         point(2.0, 2.0)\n         point(3.0, 3.0)\n         complete()\n     }\n }\n</code></pre> <pre><code>{\n  \"type\": \"Polygon\",\n  \"coordinates\": [\n    [[45.0, 45.0], [0.0, 0.0], [12.0, 12.0], [45.0, 45.0]],\n    [[4.0, 4.0], [2.0, 2.0], [3.0, 3.0], [4.0, 4.0]]\n  ]\n}\n</code></pre>"},{"location":"geojson/#multipolygon_1","title":"MultiPolygon","text":"<p>Like with previous \"Multi\" geometries, the unary plus operator is used to add multiple <code>Polygon</code> objects. The <code>Polygon</code> DSL can also be used here.</p> KotlinJSON <pre><code>val simplePolygon = previousExample()\n\nmultiPolygon {\n    +simplePolygon\n    polygon {\n        ring {\n            point(12.0, 0.0)\n            point(0.0, 12.0)\n            point(-12.0, 0.0)\n            point(5.0, 5.0)\n            complete()\n        }\n    }\n}\n</code></pre> <pre><code>{\n  \"type\": \"MultiPolygon\",\n  \"coordinates\": [\n    [\n      [[45.0, 45.0], [0.0, 0.0], [12.0, 12.0], [45.0, 45.0]],\n      [[4.0, 4.0], [2.0, 2.0], [3.0, 3.0], [4.0, 4.0]]\n    ], [\n      [[12.0, 0.0], [0.0, 12.0], [-12.0, 0.0], [5.0, 5.0], [12.0, 0.0]]\n    ]\n  ]\n}\n</code></pre>"},{"location":"geojson/#geometry-collection","title":"Geometry Collection","text":"<p>The unary plus operator can be used to add any geometry instance to a <code>GeometryCollection</code>.</p> KotlinJSON <pre><code>val simplePoint: Point = previousPoint()\nval simpleLine: LineString = previousLineString()\nval simplePolygon: Polygon = previousPolygon()\n\ngeometryCollection {\n    +simplePoint\n    +simpleLine\n    +simplePolygon\n}\n</code></pre> <pre><code>{\n  \"type\": \"GeometryCollection\",\n  \"geometries\": [\n    {\n      \"type\": \"Point\",\n      \"coordinates\": [-75.0, 45.0, 100.0]\n    },\n    {\n      \"type\": \"LineString\",\n      \"coordinates\": [[45.0, 45.0], [0.0, 0.0]]\n    },\n    {\n      \"type\": \"Polygon\",\n      \"coordinates\": [\n      [[45.0, 45.0], [0.0, 0.0], [12.0, 12.0], [45.0, 45.0]],\n      [[4.0, 4.0], [2.0, 2.0], [3.0, 3.0], [4.0, 4.0]]\n      ]\n    }\n  ]\n}\n</code></pre>"},{"location":"geojson/#feature_1","title":"Feature","text":"<p>The <code>Feature</code> DSL can construct a <code>Feature</code> object with a geometry, a bounding box, and an id. Properties can be specified in the <code>PropertiesBuilder</code> block by calling <code>put(key, value)</code> to add properties.</p> KotlinJSON <pre><code>feature(geometry = point(-75.0, 45.0), id = \"point1\", bbox = BoundingBox(-76.9, 44.1, -74.2, 45.7)) {\n    put(\"name\", \"Hello World\")\n    put(\"value\", 13)\n    put(\"cool\", true)\n}\n</code></pre> <pre><code>{\n  \"type\": \"Feature\",\n  \"id\": \"point1\",\n  \"bbox\": [-76.9, 44.1, -74.2, 45.7],\n  \"properties\": {\n    \"name\": \"Hello World\",\n    \"value\": 13,\n    \"cool\": true\n  },\n  \"geometry\": {\n    \"type\": \"Point\",\n    \"coordinates\": [-75.0, 45.0]\n  }\n}\n</code></pre>"},{"location":"geojson/#feature-collection","title":"Feature Collection","text":"<p>A <code>FeatureCollection</code> is constructed by adding multiple <code>Feature</code> objects using the unary plus operator.</p> KotlinJSON <pre><code>featureCollection {\n    feature(geometry = point(-75.0, 45.0))\n}\n</code></pre> <pre><code>{\n  \"type\": \"FeatureCollection\",\n  \"features\": [\n    {\n      \"type\": \"Feature\",\n      \"geometry\": {\n        \"type\": \"Point\",\n        \"coordinates\": [-75.0, 45.0]\n      },\n      \"properties\": {}\n    }\n  ]\n}\n</code></pre>"},{"location":"ported-functions/","title":"Ported Functions","text":"<p>The following functions have been ported as of version <code>0.2.0</code> of this library.</p> <p>You can view porting progress for the next release here.</p>"},{"location":"ported-functions/#measurement","title":"Measurement","text":"<ul> <li> <code>along</code></li> <li> <code>area</code></li> <li> <code>bbox</code></li> <li> <code>bboxPolygon</code></li> <li> <code>bearing</code></li> <li> <code>center</code></li> <li> <code>centerOfMass</code></li> <li> <code>destination</code></li> <li> <code>distance</code></li> <li> <code>envelope</code></li> <li> <code>length</code></li> <li> <code>midpoint</code></li> <li> <code>pointOnFeature</code></li> <li> <code>polygonTangents</code></li> <li> <code>pointToLineDistance</code></li> <li> <code>rhumbBearing</code></li> <li> <code>rhumbDestination</code></li> <li> <code>rhumbDistance</code></li> <li> <code>square</code></li> <li> <code>greatCircle</code></li> </ul>"},{"location":"ported-functions/#coordinate-mutation","title":"Coordinate Mutation","text":"<ul> <li> <code>cleanCoords</code></li> <li> <code>flip</code></li> <li> <code>rewind</code></li> <li> <code>round</code> Use <code>round</code> or <code>Math.round</code> from the standard library instead.</li> <li> <code>truncate</code></li> </ul>"},{"location":"ported-functions/#transformation","title":"Transformation","text":"<ul> <li> <code>bboxClip</code></li> <li> <code>bezierSpline</code></li> <li> <code>buffer</code></li> <li> <code>circle</code></li> <li> <code>clone</code></li> <li> <code>concave</code></li> <li> <code>convex</code></li> <li> <code>difference</code></li> <li> <code>dissolve</code></li> <li> <code>intersect</code></li> <li> <code>lineOffset</code></li> <li> <code>simplify</code></li> <li> <code>tessellate</code></li> <li> <code>transformRotate</code></li> <li> <code>transformTranslate</code></li> <li> <code>transformScale</code></li> <li> <code>union</code></li> <li> <code>voronoi</code></li> </ul>"},{"location":"ported-functions/#feature-conversion","title":"Feature Conversion","text":"<ul> <li> <code>combine</code></li> <li> <code>explode</code></li> <li> <code>flatten</code></li> <li> <code>lineToPolygon</code></li> <li> <code>polygonize</code></li> <li> <code>polygonToLine</code></li> </ul>"},{"location":"ported-functions/#miscellaneous","title":"Miscellaneous","text":"<ul> <li> <code>kinks</code></li> <li> <code>lineArc</code></li> <li> <code>lineChunk</code></li> <li> <code>lineIntersect</code>   Partially implemented.</li> <li> <code>lineOverlap</code></li> <li> <code>lineSegment</code></li> <li> <code>lineSlice</code></li> <li> <code>lineSliceAlong</code></li> <li> <code>lineSplit</code></li> <li> <code>mask</code></li> <li> <code>nearestPointOnLine</code></li> <li> <code>sector</code></li> <li> <code>shortestPath</code></li> <li> <code>unkinkPolygon</code></li> </ul>"},{"location":"ported-functions/#helper","title":"Helper","text":"<p>Use the GeoJson DSL instead.</p>"},{"location":"ported-functions/#random","title":"Random","text":"<ul> <li> <code>randomPosition</code></li> <li> <code>randomPoint</code></li> <li> <code>randomLineString</code></li> <li> <code>randomPolygon</code></li> </ul>"},{"location":"ported-functions/#data","title":"Data","text":"<ul> <li> <code>sample</code></li> </ul>"},{"location":"ported-functions/#interpolation","title":"Interpolation","text":"<ul> <li> <code>interpolate</code></li> <li> <code>isobands</code></li> <li> <code>isolines</code></li> <li> <code>planepoint</code></li> <li> <code>tin</code></li> </ul>"},{"location":"ported-functions/#joins","title":"Joins","text":"<ul> <li> <code>pointsWithinPolygon</code></li> <li> <code>tag</code></li> </ul>"},{"location":"ported-functions/#grids","title":"Grids","text":"<ul> <li> <code>hexGrid</code></li> <li> <code>pointGrid</code></li> <li> <code>squareGrid</code></li> <li> <code>triangleGrid</code></li> </ul>"},{"location":"ported-functions/#classification","title":"Classification","text":"<ul> <li> <code>nearestPoint</code></li> </ul>"},{"location":"ported-functions/#aggregation","title":"Aggregation","text":"<ul> <li> <code>collect</code></li> <li> <code>clustersDbscan</code></li> <li> <code>clustersKmeans</code></li> </ul>"},{"location":"ported-functions/#meta","title":"Meta","text":"<ul> <li> <code>coordAll</code></li> <li> <code>coordEach</code></li> <li> <code>coordReduce</code></li> <li> <code>featureEach</code></li> <li> <code>featureReduce</code></li> <li> <code>flattenEach</code></li> <li> <code>flattenReduce</code></li> <li> <code>getCoord</code></li> <li> <code>getCoords</code></li> <li> <code>getGeom</code></li> <li> <code>getType</code></li> <li> <code>geomEach</code></li> <li> <code>geomReduce</code></li> <li> <code>propEach</code></li> <li> <code>segmentEach</code></li> <li> <code>segmentReduce</code></li> <li> <code>getCluster</code></li> <li> <code>clusterEach</code></li> <li> <code>clusterReduce</code></li> </ul>"},{"location":"ported-functions/#assertations","title":"Assertations","text":"<ul> <li> <code>collectionOf</code></li> <li> <code>containsNumber</code></li> <li> <code>geojsonType</code></li> <li> <code>featureOf</code></li> </ul>"},{"location":"ported-functions/#booleans","title":"Booleans","text":"<ul> <li> <code>booleanClockwise</code></li> <li> <code>booleanContains</code></li> <li> <code>booleanCrosses</code></li> <li> <code>booleanDisjoint</code></li> <li> <code>booleanEqual</code></li> <li> <code>booleanOverlap</code></li> <li> <code>booleanParallel</code></li> <li> <code>booleanPointInPolygon</code></li> <li> <code>booleanPointOnLine</code></li> <li> <code>booleanWithin</code></li> </ul>"},{"location":"ported-functions/#unit-conversion","title":"Unit Conversion","text":"<ul> <li> <code>bearingToAzimuth</code></li> <li> <code>convertArea</code></li> <li> <code>convertLength</code></li> <li> <code>degreesToRadians</code></li> <li> <code>lengthToRadians</code></li> <li> <code>lengthToDegrees</code></li> <li> <code>radiansToLength</code></li> <li> <code>radiansToDegrees</code></li> <li> <code>toMercator</code></li> <li> <code>toWgs84</code></li> </ul>"},{"location":"turf/","title":"Turf","text":"<p>Turfjs is a spatial analysis library for JavaScript applications and the <code>turf</code> module contains a Kotlin port of it with support for Kotlin Multiplatform projects.</p> <p>This module makes use of the classes defined in the <code>geojson</code> module as the GeoJson inputs to many of the turf functions.</p> <p>The documentation for the ported functions can be found in the API docs, while more details on each function can be found on the Turfjs site. </p>"},{"location":"turf/#installation","title":"Installation","text":"KotlinGroovy <pre><code>dependencies {\nimplementation(\"io.github.dellisd.spatialk:turf:&lt;version&gt;\")\n}\n</code></pre> <pre><code>dependencies {\n    implementation \"io.github.dellisd.spatialk:turf:&lt;version&gt;\"\n}\n</code></pre>"},{"location":"turf/#example","title":"Example","text":"<p>Turf functions are available as top-level functions in Kotlin, or as static member functions in Java.</p> Kotlin <pre><code>val point = LngLat(-75.0, 45.0)\nval (longitude, latitude) = destination(point, 100.0, 0.0)\n</code></pre>"},{"location":"turf/#turf-functions","title":"Turf Functions","text":"<p>A list of all turf functions and their current status in the port can be found on this page.</p>"},{"location":"turf/#units-of-measurement","title":"Units of Measurement","text":"<p>Units of measurement are represented using the <code>Units</code> enum. These enum values can be passed into functions to specify the units used by other values passed into the function.</p> Kotlin <pre><code>val result = convertLength(12.5, from = Units.Kilometers, to = Units.Miles)\n</code></pre> <p>Not all units are valid for every function. For example: acres cannot be used as a measure of distance. Calling a function like <code>convertLength</code> with <code>Units.Acres</code> as one of the arguments will cause an <code>IllegalArgumentException</code>.</p>"}]}